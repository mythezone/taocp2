## 1.1 算法

* 历史溯源：算法Algorithm一词的来历


* **算法E （欧几里得算法）**：
    * 这应该是现在已知最古老的算法，又被称为“辗转相除法”，用于求解两个正整数的最大公约数。
    * 出自《几何原本》第七卷命题1和命题2.
    * 算法分为三个步骤：
        > E1: [求余数]
        > E2:[余数为0？]
        > E3:[减少]
  * 使用Python实现这个算法的代码如下：

```python
def Eculid(m:int,n:int):
    '''
    求正整数m,n的最大公约数
    :param m: 给定的正整数
    :param n: 给定的正整数
    :return: 最大公约数
    '''

    r = 1  #设定随意大于0的数
    while r>0:
        r = m % n  #取余
        if r == 0:
            break
        n, m = r, n   #重新赋值（辗转相除）
    return n
```

* 算法的现代意义：recipe, process, method, technique, procedure, routine, rigmarole
* 算法的五个重要特征
  1. 有限性：要求步骤非常有限、合理
  2. 确定性
  3. 输入
  4. 输出
  5. 能行性（有效性）
* 形式的定义一个**计算方法**为一个四元组
  * 举例一个四元组作为一个函数取代前面提到的欧几里得算法
  * 另一个例子有点难懂，先做一个标记P7

## 习题

**1. [10] 用最少的替代把（a,b,c,d)变成(b,c,d,a)**
  解：显然，这里完成了一个轮换，五次替换可以完成任务如下：
t<-a, a<-b, b<-c, c<-d, d<-t 

**2.[15]证明，在步骤E1开始时，m总是大雨n的，除了这一步头一次出现时可能出现相反的情况外。**
  解：因为除了第一步以外，每次计算n都变成了m%n，m变成n，所以n是m的余数，当然必须小与n。
当余数为零时退出循环，返回最后一次的除数（即已经整除）就是最大公约数。

**3.[20]提高算法E的效率，避免m<-n这样的赋值**
  解：

```python
def Eculid_Modified(m:int,n:int):
    '''
    求正整数m,n的最大公约数
    :param m: 给定的正整数
    :param n: 给定的正整数
    :return: 最大公约数
    '''
    r = m % n   #第一次计算余数值，若为零跳过循环直接输出n
    if r == 0:
        return n
    while r>0:   #该循环内包含两次取余，可以避免简单赋值
        n = n % r  #为n赋值为此次余数值
        if n == 0:
            return r
        r = r % n
        if r == 0: #为r赋值为此次余数值
            return n

#测试
if __name__ == "__main__" :
    x=Eculid_Modified(2166,6099)
    print(x)
```

**4.[16]2166和6099的最大公因子是多少？**
  解：利用以上算法可以得到：57

**5.[12]证明“阅读本套书的流程”不是一个真正的算法。**
  解：这个流程的漏洞还挺多的。

    1. 12到13之间有一个死循环
    2. 除以上，没有终止条件，也就是说永远也看不完这本书，哈哈，作者的阴谋。

**6.[20]当n = 5 时，执行步骤E1 的平均次数T5 是多少？**
  解：E1 是相除取余，对m可以取得的任意正整数，其余数为0，1，2，3，4的概率均为0.2，之后相应的E1执行步骤为0，1，2，3，2，所以期望是1.6次。

**7.[M21]假设m已知而允许n取遍所有的正整数，令$U_m$是算法E中执行步骤E1的平均次  解：数。证明$U_m$是明确定义的。$U_m$和$T_m$有什么关系吗？**
在一次相除后，余数只可能是0至m-1之间的数
对于余数分别为0，1，2，3，...等情况，可以简单计算得需要的平均步骤依次为0，1，1.5，1.83，...
那么规律就是，下一个余数的平均步数是前面所有平均步数的平均值加1。所以可以得到$U_m$的递推公式，求得$U_m$
$$
\begin {aligned}
U_m&=\frac{U_1+U_2+\dots+U_{m-1}}{m-1}+1\\\
&=\frac{(U_{m-1}-1)\times(m-2)+U_{m-1}}{m-1}\\\
&=\frac{(U_{m-1}-1)\times(m-2)+(U_{m-1}-1)+1}{m-1}\\\
&=U_{m-1}+\frac{1}{m-1}
\end {aligned}
$$
因为分母有m-1，所以$m\geq2$,用几个数验证，没有问题
那么实际上$U_m=1+\frac{1}{2}+\frac{1}{3}+\dots++\frac{1}{m-1}$就是调和级数。当$m\to\infty$该级数发散，也就是说这个时候可能需要无穷次相除才能得到结果。



























